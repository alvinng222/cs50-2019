// recover.c
// cs50-2019 Problem set 3 - recover.c
// Sep 11, 2019

// JPEG the first three bytes of JPEGs are 0xff 0xd8 0xff,
// fourth byte, meanwhile, is either 0xe0 .. 0xef
// A photo that’s 1 MB (i.e., 1,048,576 B) thus takes up
// 1048576 ÷ 512 = 2048 "blocks" on a memory card

/* Pseudocode
open 0th image file 000.jpg
#A  do loop from
Read infile
Check Header, jpegHdr
if yes header
   closed and open new file
   next filename  ++
Just write (over) data to outptr
loop to #A . */

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h> // for bool

bool jpegHdr(int byte4);

//int main(void)
int main(int argc, char *argv[])
{
    // ensure proper usage
    if (argc != 2)
    {
        printf("Usage: recover infile\n");
        return 1;
    }

    // remember filenames
    char *infile = argv[1];

    // open input file
    FILE *inptr = fopen(infile, "r");
    if (inptr == NULL)
    {
        printf("Could not open %s.\n", infile);
        return 2;
    }

    // allocate memory for handle 512 bytes data, standard for jpeg image
    int buffer[128];

    // create and open image file by sprint
    // int sprintf(char *str, const char *format, ...);
    int fn = 0;                                     // filename from running number
    char *outfile = malloc((7 + 1) * sizeof(char)); // strlen is 7
    sprintf(outfile, "%03i.jpg", fn);               // pre-create, will be overwrite

    // open output file
    FILE *outptr = fopen(outfile, "w");
    if (outptr == NULL)
    {
        fclose(inptr);
        printf("Could not create %s.\n", outfile);
        return 3;
    }

    while (feof(inptr) != 1)
    {
        // read the first block of file
        fread(buffer, 128, 1, inptr);

        if ((jpegHdr(buffer[0]) == 0))
        {
            // close outfile
            fclose(outptr);

            //create next jpg name, open new filename
            sprintf(outfile, "%03i.jpg", fn);
            outptr = fopen(outfile, "w");
            fn++;
        }

        // just continue to write, regardless of front non-image data
        {
            fwrite(buffer, 128, 1, outptr);
        }
    }

    // close outfile
    fclose(outptr);

    // close infile
    fclose(inptr);

    // Free memory
    free(outfile);

    // success
    return 0;
}

// check if first three bytes: 0xff 0xd8 0xff,
// + fourth byte, is either 0xe0, 0xe1, 0xe2, ... 0xed, 0xee, or 0xef.
bool jpegHdr(int byte4)
{
    int Hdr = 0xe0ffd8ff;
    do
    {
        if (byte4 == Hdr)
        {
            //
            return 0;
        }

        Hdr = Hdr + 0x01000000;
    }
    while (Hdr < 0xf0000000);

    return 1;
}

/* $ rm -f *.jpg
$ valgrind ./recover card.raw
$ echo $?
0
~/work3/ $ style50 ./recover.c
~/work3/ $ check50 cs50/problems/2019/x/recover
 for results..................
Results for cs50/problems/2019/x/recover generated by check50 v3.0.8
...
:( recovers 049.jpg correctly
    recovered image does not match .  */

