// recover.c
// cs50-2019 Problem set 3 - recover.c
// Sep 11, 2019
//
//1. accept exactly one command-line argument
//A photo that’s 1 MB (i.e., 1,048,576 B) thus takes up 1048576 ÷ 512 = 2048 "blocks" on a memory card
//rm -f *.jpg
/* Pseudocode
open 0th image file 000.jpg
#A  do loop from
Read infile
Check Header, jpegHdr
if yes header
   closed and open new file
   next filename  ++
Just write (over) data to outptr
loop to #A
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h> // for bool

bool jpegHdr(int byte4);

//int main(void)
int main(int argc, char *argv[])
{
    // ensure proper usage
    if (argc != 2)
    {
        printf("Usage: recover infile\n");
        return 1;
    }

    // remember filenames
    char *infile = argv[1];
    //char *infile = "card.raw";

    // open input file
    FILE *inptr = fopen(infile, "r");
    if (inptr == NULL)
    {
        printf("Could not open %s.\n", infile);
        return 2;
    }

    // allocate memory
    //int buffer[128];
    int *buffer = malloc((128) * sizeof(int));

    int c = 0; // . TEST

    // create and open image file by sprint
    // int sprintf(char *str, const char *format, ...);
    int fn = 0;
    char *outfile = malloc((7 + 1) * sizeof(char)); // strlen is 7
    sprintf(outfile, "%03i.jpg", fn); // just 'for' overwrite

    // open output file
    FILE *outptr = fopen(outfile, "w");
    if (outptr == NULL)
    {
        fclose(inptr);
        printf("Could not create %s.\n", outfile);
        return 3;
    }

    while (feof(inptr) != 1) //o // while ( ferror(inptr) != 0)
    {
        // read the first block of file
        fread(buffer, 128, 1, inptr);

        if ((jpegHdr(buffer[0]) == 0))
        {
            //printf("OLD outfile:%s Hdr: %x buffer1: %x buffer1: %x\n", outfile, buffer[0], buffer[1], buffer[2]);
            // close outfile
            fclose(outptr);

            //create next jpg name, open new filename
            sprintf(outfile, "%03i.jpg", fn);
            outptr = fopen(outfile, "w");
            fn++;
            //printf("c: %i ", c);
            //printf("NEW outfile:%s Hdr: %x buffer1: %x buffer1: %x\n", outfile, buffer[0], buffer[1], buffer[2]);
        }

        // just continue to write, regardless
        {
            fwrite(buffer, 128, 1, outptr);
        }

        c++; // . TEST
    }
    //while (feof(inptr) != 1);

    //printf("EOF c: %i \n", c);

    // close outfile
    fclose(outptr);

    // close infile
    fclose(inptr);

    // Free memory
    free(outfile);
    free(buffer);

    // success
    return 0;
}

// check if first 3 bytes: 0xff 0xd8 0xff, ask loop to top
// The fourth byte, is either 0xe0, 0xe1, 0xe2, ... 0xed, 0xee, or 0xef.
bool jpegHdr(int byte4)
{
    int Hdr = 0xe0ffd8ff;
    do
    {
        if (byte4 == Hdr)
        {
            //
            return 0;
        }

        Hdr = Hdr + 0x01000000;
    }
    while (Hdr < 0xf0000000);

    return 1;
}


/*
$ rm -f *.jpg
$ valgrind ./recover card.raw
$ echo $?
0

~/work3/ $ style50 ./recover.c
~/work3/ $ check50 cs50/problems/2019/x/recover
 for results..................
Results for cs50/problems/2019/x/recover generated by check50 v3.0.8
:) recover.c exists.
:) recover.c compiles.
:) handles lack of forensic image
:) recovers 000.jpg correctly
:) recovers middle images correctly
:( recovers 049.jpg correctly
    recovered image does not match
To see the results in your browser go to https://submit.cs50.io/check50/ab52d14c170a511f9540ad89da2fab66ac4bf91d
~/work3/ $
*/

/*
: 89620 NEW outfile:049.jpg Hdr: e0ffd8ff buffer1: 464a1000 buffer1: 1004649
EOF c: 91029
*/

